## java lession note 02 

* 01  算术运算符 》 关系运算符 》 逻辑运算符 (一般来说，大概就是这几块儿，且优先级如左所示)
* 02  对于数值来说 ，大精度到小精度 ，需要强制类型转换 ，形式是 变量 = （类型）需要转换的变量 ；
* 03  小精度到大精度 ，执行自动类型转换
* 04  算术运算结果 ，至少为int .
```
byte b2 = 3,b3 = 4 ;
byte b1 = b2 + b3 ;
```
> 会报错 ,b2+b3 后成为int ,所以还需要强制类型转换

* 05  a += b  不只是 a = a + b, 它还会提供隐式的类型转换 .
```
byte b1=3,b2=4;
b1 += b2;
```
> 就不会报错

* 06  null 可以强制转换成任何java 类类型
* 07  % 的结果只和第一个参数的正负有关

> 当a、b 均为字符型(或者字节型、短整型、整型、长整型、单精度浮点型、双精度浮点型)时，它们是可以进行% 运算的. 

* 08  移位有一点坑，实际移位是 `移位的值 % 对应类型的位长` 的值
```
12 >> 2 = 3;
12 >> 34 = 3;
12 >>> 34 = 3;
```
> int 32位, 实际位移 34 % 32 = 2 位 

* 09  & | 可以做逻辑运算，不过没有短路效果 -----   && || 这是短路运算符
* 10  布尔类型不能从其他任何类型强制转换 ，非对象类不能和对象类相互转化 
* 11  String 类的值是只读的不可修改的(immutable) 
```
String str = "hello world";
String b = str.subString(0,6);
str = str.subString(0,6);
```
> b 获得新串引用 ，str没有改变 ；之后，str 指向了另一个对象 ，原对象其实没变(好吧，变成垃圾 ，要被回收了) 不断生成新对象，所以会有点慢

* 12  将String 拆分成byte 数组 
```
String.getBytes(String charset) 
```
> 不填参数则默认使用操作系统默认的字符集 ，这很危险(乱码) ，一定不要缺省

* 13  字节数组构建字符串 ，也可以设置字符集  
```
String s = new String( byte[] bytes, String charset );
```
> 这个和12 结合，貌似可以用来转换字符集

* 14  栈内局部变量(有点别扭) 初始化后才分配空间
```
int i;
//...
// System.out.println(i);  //报错..
i = 1;
```
> i = 1 之后栈中才为i 分配空间 | 之前i 不存在， 不能打印

* 15  静态方法一般用作工具，与对象无关，(省一些构造开销?)
* 16  访问局部变量快，优先级高； 在不是很注重内存的情况下，缓存常用对象的部分属性可以提高效率

 
