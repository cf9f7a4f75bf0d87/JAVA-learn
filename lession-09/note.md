## java learn note 09

* 01	事件处理机制和计算机的中断机制类似， 减少了循环等待的开销， 只有事件发生时， 才会引起对应方法的调用; 否则，为了捕获对应事件， 必须持续监听， 类似程序查询方式
* 02 	事件处理机制元素
	*   事件源（  谁出的事 ？ ）
	*   事件（ 出的什么事 ? )
  *   事件监听（ 报警的路人， 通知对应处理主体 ）
  *   事件处理主体（ 负责处理事件 ）
* 03  大致关系
	*   一个事件必须有事件源
  *   一个事件源可以产生多种事件， 同一个事件可以由多种对象产生
  *   产生的事件可以处理，也可以不处理
  *   如果处理，可以由事件源本身处理，也可以（其实是大多数）由其他对象进行** 04  java 对应的涉及
  * 	事件源类 
	*		事件类 （ EventObject ） 
	* 	事件监听者接口（ EventListener ) 沟通事件源和监听者
  * 	事件监听者类（ 事件处理主体 ） 实现对应监听接口，完成处理
* 05  设计模式 观察者模式
* 06  java 大致类的关系
	*   事件源中 有一个监听者队列， 可以增删监听者
	*   当发生事件时， 事件源 new 一个 事件类的实例 然后 分发给队列中的处理类
	*   对于处理类， 只需要实现对应接口， 之后就等待被调用就可以
* 07	类的结构 - 事件源
  *		事件源 独立的类（不需要继承其他类，一般是自定义的） 
	*		需要有监听对象队列(集合什么的也行） 
	*		增加监听对象 删除监听对象
  *   封装一下通知逻辑（？）
	*		生成新事件对象
* 08	类的结构 - 事件
	*		继承EventObject
	* 	定义私有成员变量， 表示需要提供的信息（一般通过get..方法传出）
	*		构造函数（一般重载多个） 和 set get 方法
* 09  类的结构 - 监听接口
	* 	继承EventLisetener
	*		参数一般就一个事件类型， 其他如果需要的数据最好还是封装到事件类型中
	*		可定义不只一个函数， （多个的话，可能需要编写基础的适配器类）
* 10	类的结构 - 监听者
	*		一是 可以实现（impliments） 监听接口， 所以声明函数都要实现
	*		二是 继承适配器 只重写需要的函数即可

